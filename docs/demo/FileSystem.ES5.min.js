"use strict"; function _toConsumableArray(e) { if (Array.isArray(e)) { for (var t = 0, n = Array(e.length); t < e.length; t++)n[t] = e[t]; return n } return Array.from(e) } function _possibleConstructorReturn(e, t) { if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !t || "object" != typeof t && "function" != typeof t ? e : t } function _inherits(e, t) { if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t); e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t) } function _classCallCheck(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") } var _createClass = function () { function e(e, t) { for (var n = 0; n < t.length; n++) { var r = t[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r) } } return function (t, n, r) { return n && e(t.prototype, n), r && e(t, r), t } }(); !function () { var e = { FILE_EXISTED: "文件已存在", Directory_EXISTED: "目录已存在", ONLY_FILE_WRITE: "只有文件才能写入", NOT_ENTRY: "不是有效的Entry对象", INVALID_PATH: '文件名不能包含\\/:*?"<>|' }, t = String.fromCharCode("/".charCodeAt(0) + 1), n = function (e, t, n) { var r = [], i = void 0, a = Promise.resolve(); return Array.from(e).forEach(function (e, o) { a = a.then(function () { return t(e, o).then(function (e) { i = e, n && r.push(e) }) }) }), n ? a.then(function () { return r }) : a }, r = { _pathBlackList: /[/\\:*?"<>|]/, resolveToFullPath: function (e, t) { var n = t; "/" != t[0] && (n = e + "/" + t); for (var r = n.split("/"), i = [], a = 0; a < r.length; ++a) { var o = r[a]; if (".." === o) { if (!i.length) throw Error("Invalid path"); i.pop() } else "." === o || "" !== o && i.push(o) } return n = "/" + i.join("/") }, isValidatedPath: function (e) { return !!this._pathBlackList.test(e) } }, i = function e() { var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : { code: 999, message: "未知错误" }, n = t.code, r = void 0 === n ? 999 : n, i = t.message, a = void 0 === i ? "未知错误" : i; _classCallCheck(this, e), this.code = r, this.message = a }, a = function e(t, n) { _classCallCheck(this, e), this.modificationTime = t, this.size = n }, o = function e(t, n, r, i, a) { _classCallCheck(this, e), this.name = t, this.size = n, this.type = r, this.lastModifiedDate = i, this.blob = a }, s = { read: function (e, t) { var n = arguments; return new Promise(function (r, i) { var a = new FileReader, o = [].slice.call(n, 2); o.unshift(e), a[t].apply(a, o), a.onload = function () { return r(a.result) }, a.onerror = function (e) { return i(e) }, a.onabort = function () { return i(new Error("读取被中断")) } }) }, readAsArrayBuffer: function (e) { return this.read(e, "readAsArrayBuffer") }, readAsBinaryString: function (e) { return this.read(e, "readAsBinaryString") }, readAsDataURL: function (e) { return this.read(e, "readAsDataURL") }, readAsText: function (e) { var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "gb2312"; return this.read(e, "readAsText", t) } }, l = new i({ code: 1e3, message: "方法未实现" }), u = new i({ code: 404, message: "未找到" }), c = new Error("So Low , So Young"), f = function () { function e() { var t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0], n = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], r = arguments[2], i = arguments[3]; _classCallCheck(this, e), this.isFile = t, this.isDirectory = n, this.name = r, this.fullPath = i, this.metadata = { lastModifiedDate: new Date, size: 0 } } return _createClass(e, [{ key: "getMetadata", value: function () { return this._dispatch("getMetadata") } }, { key: "moveTo", value: function () { throw l } }, { key: "copyTo", value: function () { throw l } }, { key: "toURL", value: function () { return this._dispatch("toURL") } }, { key: "remove", value: function () { return this._dispatch("remove") } }, { key: "getParent", value: function () { return this._dispatch("getParent") } }]), e }(); f.prototype._dispatch = function (e) { for (var t = this, n = arguments.length, r = Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++)r[i - 1] = arguments[i]; return new Promise(function (n) { if (y._instance) { var i; return n((i = y._instance)[e].apply(i, [t].concat(r))) } return y.getInstance().then(function (i) { var a; return y._instance = i, n((a = y._instance)[e].apply(a, [t].concat(r))) }) }) }, f.copyFrom = function (e) { var t = e.isFile ? new h(e.name, e.fullPath, e.file) : new d(e.name, e.fullPath); return t.metadata = e.metadata, t }; var h = function (e) { function t(e, n, r) { _classCallCheck(this, t); var i = _possibleConstructorReturn(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, !0, !1, e, n)); return i.file = r, i } return _inherits(t, f), _createClass(t, [{ key: "write", value: function (e) { var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "text/plain", n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; return this._dispatch("write", e, t, n) } }, { key: "getBlob", value: function () { return this._dispatch("getBlob") } }, { key: "readAsArrayBuffer", value: function () { return this._dispatch("readFile", "readAsArrayBuffer") } }, { key: "readAsBinaryString", value: function () { return this._dispatch("readFile", "readAsBinaryString") } }, { key: "readAsDataURL", value: function () { return this._dispatch("readFile", "readAsDataURL") } }, { key: "readAsText", value: function () { var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "utf-8"; return this._dispatch("readFile", "readAsText", e) } }]), t }(), d = function (e) { function t(e, n) { return _classCallCheck(this, t), _possibleConstructorReturn(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, !1, !0, e, n)) } return _inherits(t, f), _createClass(t, [{ key: "getFile", value: function (e) { var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : { create: !0, exclusive: !1 }; return this._dispatch("getFile", e, t) } }, { key: "getDirectory", value: function (e) { var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : { create: !0, exclusive: !1 }; return this._dispatch("getDirectory", e, t) } }, { key: "remove", value: function () { return this._dispatch("removeRecursively") } }, { key: "getEntries", value: function () { return this._dispatch("getEntries") } }, { key: "ensureDirectory", value: function (e) { return this._dispatch("ensureDirectory", e) } }]), t }(), y = function () { function l() { _classCallCheck(this, l), this._db = null, this._instance = null, this._storeName = l._storeName, this.root = null } return _createClass(l, [{ key: "_toPromise", value: function (e) { for (var t = this, n = arguments.length, r = Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++)r[i - 1] = arguments[i]; try { var a = void 0; return r.length >= 1 && "function" == typeof r[r.length - 1] && (a = r[r.length - 1], r = r.slice(0, r.length - 1)), new Promise(function (n, i) { var o, s = t.transaction, l = (o = s.objectStore(t._storeName))[e].apply(o, _toConsumableArray(r));["openCursor", "openKeyCursor"].indexOf(e) >= 0 && a ? (l.onsuccess = function (e) { a(e) }, s.oncomplete = function () { return n() }, s.onsuccess = function () { return n() }) : (s.oncomplete = function () { return n(l.result) }, s.onsuccess = function () { return n(l.result) }), l.onerror = function () { return i(l.error) }, s.onerror = function () { return i(s.error) } }) } catch (e) { return Promise.reject(e) } } }, { key: "write", value: function (t, n) { var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "text/plain"; arguments.length > 3 && void 0 !== arguments[3] && arguments[3]; if (this._checkEntry(t), !0 !== t.isFile) throw new i({ message: e.ONLY_FILE_WRITE }); var a = n; a = n instanceof ArrayBuffer ? new Blob([new Uint8Array(n)], { type: r }) : "string" == typeof n ? new Blob([n], { type: "text/plain" }) : new Blob([n], { type: r }); var s = t.file; return s ? (s.lastModifiedDate = new Date, s.type = r, s.size = a.size, s.blob = a, t.metadata.lastModifiedDate = s.lastModifiedDate, t.metadata.size = a.size) : (s = new o(t.fullPath.split("/").pop(), a.size, r, new Date, a), t.metadata.lastModifiedDate = s.lastModifiedDate, t.metadata.size = a.size, t.file = s), this._toPromise("put", t, t.fullPath).then(function () { return t }) } }, { key: "getFile", value: function (e, t, n) { n.create, n.exclusive; return this.getEntry.apply(this, Array.prototype.slice.call(arguments).concat([!0])) } }, { key: "getDirectory", value: function (e, t, n) { n.create, n.exclusive; return this.getEntry.apply(this, Array.prototype.slice.call(arguments).concat([!1])) } }, { key: "remove", value: function (e) { return this._checkEntry(e), this._toPromise("delete", e.fullPath).then(function () { return !0 }) } }, { key: "removeRecursively", value: function (e) { this._checkEntry(e); var n = IDBKeyRange.bound(e.fullPath, e.fullPath + t, !1, !0); return this._toPromise("delete", n).then(function () { return !0 }) } }, { key: "getMetadata", value: function (e) { var t = e.file || {}; return new a(t && t.lastModifiedDate || null, t && t.size || 0) } }, { key: "getEntry", value: function (t, n, a) { var s = this, l = a.create, c = a.exclusive, y = void 0 !== c && c, v = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3]; return this._checkEntry(t), "/" === n ? t : (n = r.resolveToFullPath(t.fullPath, n), this._toPromise("get", n).then(function (t) { if (!0 === l && !0 === y && t) throw new i({ message: v ? e.FILE_EXISTED : e.Directory_EXISTED }); if (!0 !== l || t) { if (l || t) { if (t && t.isDirectory && v || t && t.isFile && !v) throw new i({ code: 1001, message: v ? e.Directory_EXISTED : e.FILE_EXISTED }); return f.copyFrom(t) } throw u } var r = n.split("/").pop(), a = v ? new h(r, n) : new d(r, n), c = v ? new o(r, 0, null, new Date, null) : null; return v && (a.file = c), s._toPromise("put", a, a.fullPath).then(function () { return f.copyFrom(a) }) })) } }, { key: "getParent", value: function (e) { if (this._checkEntry(e), "/" === e.fullPath) return e; var t = e.fullPath.substring(0, e.fullPath.lastIndexOf("/")); return "" === t ? this.root : this.getDirectory(this.root, t, { create: !1 }, !1) } }, { key: "getEntries", value: function (e) { var n = null, r = []; "/" != e.fullPath && "" != e.fullPath && (n = IDBKeyRange.bound(e.fullPath + "/", e.fullPath + t, !1, !0)); var i = void 0, a = void 0; return this._toPromise("openCursor", n, function (t) { var n = t.target.result; if (n) { var o = n.value; i = o.fullPath.split("/").length, a = e.fullPath.split("/").length, "/" !== o.fullPath && ("/" === e.fullPath && i < a + 1 || "/" !== e.fullPath && i === a + 1) && r.push(o.isFile ? new h(o.name, o.fullPath, o.file) : new d(o.name, o.fullPath)), n.continue() } }).then(function () { return r }) } }, { key: "toURL", value: function (e) { return this._checkEntry(e), e.file && e.file.blob ? URL.createObjectURL(e.file.blob) : null } }, { key: "readFile", value: function (e, t) { if (this._checkEntry(e), e.file && e.file.blob) { for (var n = arguments.length, r = Array(n > 2 ? n - 2 : 0), i = 2; i < n; i++)r[i - 2] = arguments[i]; return s.read.apply(s, [e.file.blob, t].concat(r)) } throw u } }, { key: "getBlob", value: function (e) { if (this._checkEntry(e), e.file && e.file.blob) return e.file.blob; throw u } }, { key: "_checkEntry", value: function (t) { if (!(t && t instanceof f)) throw new i({ message: e.NOT_ENTRY }) } }, { key: "ensureDirectory", value: function (e, t) { if (this._checkEntry(e), "/" === t) return e; var i = r.resolveToFullPath(e.fullPath, t); if (i.length < t.length) return e; var a = (t = i.substring(e.fullPath.length)).split("/"); return n(a, function (t, n) { return e.getDirectory(a.slice(0, n + 1).join("/"), { create: !0 }) }, !0).then(function (e) { return e && e[e.length - 1] }).catch(function (e) { throw e }) } }, { key: "transaction", get: function () { return this._db.transaction([this._storeName], IDBTransaction.READ_WRITE || "readwrite") } }], [{ key: "getInstance", value: function () { var e = this, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1; if (!l.isSupported) throw c; return this._instance && Promise.resolve(this._instance), new Promise(function (n, r) { var i = self.indexedDB.open(l._dbName, t); i.onerror = function () { return r(null) }, i.onsuccess = function () { var r = i.result; return r.setVersion && r.version !== t ? (r.setVersion(t).onsuccess = function () { return r.createObjectStore(this._storeName), this._instance = new l, this._instance._db = i.result, this._instance.root = new d("/", "/"), l._instance = this._instance, n(this._instance) }, null) : (e._instance = new l, e._instance._db = i.result, e._instance.root = new d("/", "/"), l._instance = e._instance, n(e._instance)) }, i.onupgradeneeded = function (t) { t.target.result.createObjectStore(e._storeName) } }) } }]), l }(); y.isSupported = function () { return self.indexedDB_ = self.indexedDB || self.mozIndexedDB || self.webkitIndexedDB || self.msIndexedDB, self.IDBTransaction = self.IDBTransaction || self.webkitIDBTransaction || self.msIDBTransaction, self.IDBKeyRange = self.IDBKeyRange || self.webkitIDBKeyRange || self.msIDBKeyRange, !!(self.indexedDB && self.IDBTransaction && self.IDBKeyRange) }, y._dbName = "_fs_db_", y._storeName = "_fs_store", self.FILE_ERROR = e, self.URLUtil = r, self.ReaderUtil = s, self.Entry = f, self.FileEntry = h, self.DirectoryEntry = d, self.FileSystem = y }(self);